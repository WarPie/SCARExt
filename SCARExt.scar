{$L SCARExt.dll}
{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=]
|| What is this: In short I would define SCAREXT as a grabage collection.
|| Alpha v0.1
|| - SLACKY
[=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
{$I Plotter.scar}

{=-=-=-=-=-=-=-= SCARExt.dll contains the following functions -=-=-=-=-=-=-=-=]
|| Close to every function we got start with `XT_`. So to find am do:
|| Load this include file in SCAR, write `XT_` then press Ctrl+Space ;)
||
|| Plus the plotting lib: TPlot!
[=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}
type
  XT_MatchAlgo = (LAB, LCH);


{* 
  Convert ATIA to STR (for debugging)...
*}
function ATIAToStr(ATIA: T2DIntArray): String;
var
  i: Integer;
begin
  Result := '[';
  for i:=0 to High(ATIA) do begin
    Result := Result + '('+ TIAToStr(ATIA[i]) + ')';
    if i < High(ATIA) then Result := Result + ', ';
  end;
  Result := Result + ']'
end;  
  
{*
 Copy the client area as bitmap from X->Y2
*}
function XT_ScreenAreaBMP(XS,YS,XE,YE: Integer): TSCARBitmap;
begin 
  Result := GetClient.CaptureEx(XS,YS,XE,YE); 
end;


{*
 ....
*}
procedure XT_ClientSize(var Width, Height: Integer);
begin
  GetBoxSize(GetClient.ImageArea, Width, Height);
end;


{*
 Get all the pixels on the bitmap as a ATIA (ImgArray)..
*}
function XT_Bmp2Array(bmp: TSCARBitmap; DoFree:Boolean): T2DIntArray;
var TIA:TIntArray;
begin
  TIA := BMP.GetPixels(TPAFromBox(Box(0, 0, BMP.Width-1, BMP.Height-1))); 
  Result := XT_TIAToATIA(TIA, BMP.Width,  BMP.Height);  
  if DoFree then BMP.Free;
end;


{*
 Set all the pixels from an ATIA (ImgArray) to the bitmap..
*}
procedure XT_BmpSetData(var bmp: TSCARBitmap; Matrix:T2DIntArray; Adapt:Boolean);
var 
  W,H:Integer;
  TPA:TPointArray;
begin
  W := Length(Matrix[0]); 
  H := Length(Matrix);
  if Adapt then
    if (W > bmp.Width) or (H > bmp.Height) then
      bmp.SetSize(Max(W,bmp.Width),Max(H,bmp.Height));
  TPA := TPAFromBox(Box(0, 0, W-1, H-1));
  bmp.SetPixelsEx(TPA, XT_ATIAGetValues(Matrix, TPA));
  SetLength(TPA, 0);
end;


{*
 Set all the pixels from an ATIA (ImgArray) to the bitmap. 
 If the Matrix contains AlphaColor then that pixel/index will not be changed in the bitmap..
*}
procedure XT_BmpSetDataEx(var bmp: TSCARBitmap; Matrix:T2DIntArray; Adapt:Boolean; AlphaColor:Integer);
var 
  W,H:Integer;
  NewW, NewH:Integer; 
  TPA:TPointArray;
  Mat:T2DIntArray;
begin
  W := Length(Matrix[0]); 
  H := Length(Matrix);
  NewW := Max(W, bmp.Width);
  NewH := Max(H, bmp.Height);
  Mat := XT_Bmp2Array(bmp, False);
  if Adapt then
    if (NewW <> bmp.Width) or (NewH <> bmp.Height) then
      bmp.SetSize(NewW,NewH);
  TPA := TPAFromBox(Box(0, 0, W-1, H-1)); 
  XT_ATIACombine(Matrix, Mat, AlphaColor); 
  bmp.SetPixelsEx(TPA, XT_ATIAGetValues(Matrix, TPA));
  SetLength(TPA, 0);
  SetLength(Mat, 0);
end;


(*
  Fills the TPA with the found colors. It currently supports two algorithms CIE-LAB, and CIE-LCH.
  For CIE-LCH:
    ATol = Tolerance for Chroma, and Lightness. It maxes at 142.
    BTol = Tolerance for Hue. It maxes at 180.

  For CIE-LAB:
   ATol = Tolerance for A and B, they meassure the Chroma and Hue. It maxes at 142.
   BTol = Tolerance for Lightness. It maxes at 100.
*)
function XT_FindColorTolEx(var TPA:TPointArray; Color:Integer; XS,YS,XE,YE:Integer; ATol,BTol:Integer; MatchAlgo: XT_MatchAlgo): Boolean;
var 
  W,H:Integer;
  Img:T2DIntArray;
begin
  Result := False;
  XT_ClientSize(W,H); 
  if (XE > W) or (XE = -1) then XE := W;
  if (YE > H) or (YE = -1) then YE := H;
  if (XS > XE) or (YS > YE) then Exit;
  
  Img := XT_Bmp2Array(XT_ScreenAreaBMP(XS,YS,XE,YE), true);
  case MatchAlgo of 
    LAB: Result := XTCore_FindColorTolExLAB(Img, TPA, Color, ATol, BTol);
    LCH: Result := XTCore_FindColorTolExLCH(Img, TPA, Color, ATol, BTol);
  end;
  SetLength(Img, 0);
  if (XS=0) and (YS=0) then Exit;
  XT_MoveTPA(TPA,XS,YS);
  
end;


{*
 .... Will probably be removed..
*}
function XT_BMPFindEdges(BMP:TSCARBitmap; MinDiff:Integer): TPointArray;
var 
  Img:T2DIntArray;
  W,H:Integer;
begin
  XT_ClientSize(W,H);
  Img := XT_Bmp2Array(XT_ScreenAreaBMP(0,0,W,H), True);
  Result := XT_ImCEdges(Img, MinDiff);
  SetLength(Img, 0);
end;